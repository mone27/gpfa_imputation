# AUTOGENERATED! DO NOT EDIT! File to edit: ../lib_nbs/20_Gaussian.ipynb.

# %% auto 0
__all__ = ['ListNormal', 'Normal', 'ListMNormal', 'MNormal', 'conditional_guassian', 'to_posdef', 'cov2std']

# %% ../lib_nbs/20_Gaussian.ipynb 3
from collections import namedtuple
from fastcore.basics import patch

# %% ../lib_nbs/20_Gaussian.ipynb 6
ListNormal = namedtuple('ListNormal', ['mean', 'std'])

# %% ../lib_nbs/20_Gaussian.ipynb 7
Normal = namedtuple('Normal', ['mean', 'std'])

# %% ../lib_nbs/20_Gaussian.ipynb 8
@patch
def __getitem__(self: ListNormal, n:int
           )->Normal:
    """Get the mean and cov for the nth Normal distribution in the list """
    return Normal(self.mean[n], self.std[n])

# %% ../lib_nbs/20_Gaussian.ipynb 9
@patch
def detach(self: ListNormal)->ListNormal:
    """Detach both mean and cov at once """
    return ListNormal(self.mean.detach(), self.std.detach())

# %% ../lib_nbs/20_Gaussian.ipynb 12
ListMNormal = namedtuple('ListMultiNormal', ['mean', 'cov'])

# %% ../lib_nbs/20_Gaussian.ipynb 13
MNormal = namedtuple('MultiNormal', ['mean', 'cov'])

# %% ../lib_nbs/20_Gaussian.ipynb 14
@patch
def __getitem__(self: ListMNormal, n:int
           )->Normal:
    """Get the mean and cov for the nth Normal distribution in the list """
    return MNormal(self.mean[n], self.cov[n])

# %% ../lib_nbs/20_Gaussian.ipynb 15
@patch
def detach(self: ListMNormal)->ListMNormal:
    """Detach both mean and cov at once """
    return ListMNormal(self.mean.detach(), self.cov.detach())

# %% ../lib_nbs/20_Gaussian.ipynb 20
import torch
from torch.distributions import MultivariateNormal
from torch.linalg import cholesky
from torch import cholesky_inverse
from torch import Tensor

from fastcore.test import *
from .utils import *

# %% ../lib_nbs/20_Gaussian.ipynb 24
def conditional_guassian(
                         μ: Tensor, # mean with shape `[n_vars]`
                         Σ: Tensor, # cov with shape `[n_vars, n_vars] `
                         obs: Tensor, # Observations with shape `[n_obs]`, where `n_obs = sum(idx)`
                         idx: Tensor # Boolean tensor specifying for each variable is observed (True) or not (False). Shape `[n_vars]`
                        ) -> ListNormal: # Distribution conditioned on observations. shape `[n_vars - n_obs]`
    assert μ.shape[0] == idx.shape[0]
    assert obs.shape[0] == sum(idx)
    
    μ_x = μ[~idx]
    μ_o = μ[idx]
    
    Σ_xx = Σ[~idx,:][:, ~idx]
    Σ_xo = Σ[~idx,:][:, idx]
    Σ_ox = Σ[idx,:][:, ~idx]
    Σ_oo = Σ[idx,:][:, idx]
    
    Σ_oo_inv = cholesky_inverse(cholesky(Σ_oo))
    
    
    mean = μ_x + Σ_xo@Σ_oo_inv@(obs - μ_o)
    cov = Σ_xx - Σ_xo@Σ_oo_inv@Σ_ox
    
    return ListNormal(mean, cov)
    

# %% ../lib_nbs/20_Gaussian.ipynb 28
def to_posdef(A):
    return A @ A.mT + 1e-3

# %% ../lib_nbs/20_Gaussian.ipynb 45
def cov2std(x):
    "convert cov of array of covariances to array of stddev"
    return torch.diagonal(torch.sqrt(x), dim1=1, dim2=2)
