# AUTOGENERATED! DO NOT EDIT! File to edit: ../../lib_nbs/kalman/01_Kalman_Models.ipynb.

# %% auto 0
__all__ = ['ListNormal', 'KalmanModel', 'LocalLevelModel', 'LocalSlopeModel']

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 5
import pandas as pd
from fastcore.basics import store_attr
import numpy as np

import pykalman
from numpy.ma import MaskedArray
import numpy as np
from fastcore.meta import delegates
from fastcore.basics import patch
from typing import Collection
from collections import namedtuple
from ..results import ImputationResult, _display_as_row, _plot_error_bar
import altair as alt

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 12
# this is just a duplicate of NormParam, but with a better name
ListNormal = namedtuple('ListNormal', ['mean', 'cov'])

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 14
class KalmanModel():
    "Base Model for Kalman filter that wraps `pykalman.KalmanFilter`. Doesn't support parameters that change over time"
    _var_names = None
    @delegates(pykalman.KalmanFilter)
    def __init__(self,
                 data: MaskedArray, # numpy array of observations
                 **kwargs):
        self.data = data
        self.n_obs = data.shape[0]
        self.n_features = data.shape[1]
        
        self.model = pykalman.KalmanFilter(**kwargs)
    
    def fit(self, n_iter: int=5, em_vars=None, smooth=True):
        "fit parameters using EM and calc state using smoother"
        self.model.em(self.data, n_iter=n_iter, em_vars=em_vars)
        mean, cov = self.model.smooth(self.data) if smooth else self.model.filter(self.data)
        self.state = ListNormal(mean, cov)
        return self
    
    def _obs_from_state(self, state_mean, state_cov):
        mean = self.model.observation_matrices @ state_mean
        cov = self.model.observation_matrices @ state_cov @ self.model.observation_matrices.T + self.model.observation_covariance
        return mean, cov
    def predict(self,
                times: np.ndarray # times for predictions (indices of the training data)
               ):
        "Predicts observed varibles values at the given times"
        # predicting outside the training data is not supported (yet)
        assert times.max() < self.n_obs
        means = np.empty((times.shape[0], self.n_features,))
        covs = np.empty((times.shape[0], self.n_features, self.n_features,)) 
        for i, t in enumerate(times):
            mean, cov = self._obs_from_state(self.state.mean[t], self.state.cov[t])
            means[i] = mean
            covs[i] = cov
        return ListNormal(means, covs)
    
    @property
    def latent_names(self):
        return [f"z_{i}" for i in range(self.model.transition_matrices.shape[0])]
    
    @property
    def var_names(self):
        return self._var_names if self._var_names is not None else [f"x_{i}" for i in range(self.n_features)]
    
    @var_names.setter
    def var_names(self, var_names):
        self._var_names = var_names
    

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 24
def _array2df(x, row_names, col_names, row_var):
    df = pd.DataFrame(x, columns=col_names)
    if row_names is not None: df.insert(0, row_var, row_names)
    return df

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 25
@patch
def get_info(self: KalmanModel, var_names=None):
    out = {}
    if var_names is not None: self.var_names = var_names 
    # latent names can use the updated var_names name
    latent_names = self.latent_names
    out['A'] = _array2df(self.model.transition_matrices, latent_names, latent_names, 'latent')
    out['H'] = _array2df(self.model.observation_matrices, var_names, latent_names, 'variable')
    out['R'] = _array2df(self.model.observation_covariance, var_names, var_names, 'variable')
    out['Q'] = _array2df(self.model.transition_covariance, latent_names, latent_names, 'latent')
    return out

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 28
def _shift_1d(a, shift):
    a = np.roll(a, shift, axis=0)
    if shift> 0: a[:shift, :] = np.nan
    else: a[shift:, :] = np.nan 
    
    return a

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 32
class LocalLevelModel(KalmanModel):
    "Local level model using a kalman filter"
    def __init__(self, data):
        transition_matrices = observation_matrices = np.eye(data.shape[1])
        # init with cov of transition of data
        transition_covariance = np.diag(np.nanvar(data - _shift_1d(data, -1), axis=0))
        em_vars = ['transition_covariance', 'observation_covariance']
        
        super().__init__(data, transition_matrices=transition_matrices, observation_matrices = observation_matrices, transition_covariance=transition_covariance, em_vars=em_vars )
        

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 47
def _init_local_slope(n_features):
    Zero = np.zeros((n_features, n_features), dtype=np.float32)
    I = np.eye(n_features)

    A = np.vstack([np.hstack([I   , I]),
                   np.hstack([Zero, I])])
    H = np.hstack([I, Zero])
    return A, H

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 49
class LocalSlopeModel(KalmanModel):
    "Local slope model using a kalman filter"
    # @classmethod
    def __init__(self, data):
        A, H = _init_local_slope(data.shape[1])
        em_vars = ['transition_covariance', 'observation_covariance']
        
        super().__init__(data, transition_matrices=A, observation_matrices = H, em_vars=em_vars )
    
    @property
    def latent_names(self):
        return [f"level_{var}" for var in self.var_names] + [f"slope_{var}" for var in self.var_names] 

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 64
def _cov2std(x):
    "convert cov of array of covariances to array of stddev"
    return np.diagonal(np.sqrt(x), axis1=1, axis2=2)

# %% ../../lib_nbs/kalman/01_Kalman_Models.ipynb 65
@patch
def plot_state(self: KalmanModel, n_cols = 2, bind_interaction = True, properties={}):

    s_mean, s_cov = self.state
    s_std = _cov2std(s_cov)
    
    time = np.arange(self.n_obs)
    
    mean = _array2df(s_mean, time, self.latent_names, 'time').melt('time', value_name='mean')
    std = _array2df(s_std, time, self.latent_names, 'time').melt('time', value_name='std' )
    
    state = pd.merge(mean, std, on=['time', 'variable'])
    
    plot_list = [alt.hconcat() for _ in range(0, len(self.latent_names), n_cols)]
    selection_scale = alt.selection_interval(bind="scales", encodings=['x']) if bind_interaction else None
    for idx, variable in enumerate(self.latent_names):
        data = state[state.variable == variable]
        plot_list[idx // n_cols] |= _plot_error_bar(data,
                                                   variable,
                                                   y_label = variable,
                                                   sel = selection_scale, properties=properties)
    
    plot = alt.vconcat(*plot_list)
    
    return plot

